<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Wall: Ultimate Edition</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@500;700;900&family=Rajdhani:wght@500;700&display=swap');

        :root {
            --neon-blue: #00f3ff;
            --neon-pink: #bc13fe;
            --neon-green: #39ff14;
            --neon-red: #ff003c;
            --bg-dark: #050505;
            --panel-bg: #0b0c10;
        }

        body {
            margin: 0;
            padding: 0;
            background-color: var(--bg-dark);
            color: white;
            font-family: 'Rajdhani', sans-serif;
            overflow: hidden;
            width: 100vw;
            height: 100vh;
            display: flex; 
            flex-direction: row; 
        }

        /* --- LEFT: CONTROLS --- */
        #control-panel {
            width: 380px;
            height: 100vh;
            background: var(--panel-bg);
            border-right: 1px solid #222;
            display: flex;
            flex-direction: column;
            padding: 24px;
            box-sizing: border-box;
            z-index: 20;
            box-shadow: 10px 0 40px rgba(0,0,0,0.6);
            flex-shrink: 0;
        }

        /* --- RIGHT: GAME STAGE --- */
        #game-stage {
            flex-grow: 1;
            height: 100vh;
            position: relative;
            background: #000;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 10;
        }

        canvas { 
            box-shadow: 0 0 80px rgba(0, 243, 255, 0.05); 
        }

        /* --- UI OVERLAYS --- */
        .score-box {
            position: absolute;
            top: 25px;
            padding: 15px 30px;
            background: rgba(10, 15, 20, 0.9);
            border: 1px solid #333;
            border-radius: 6px;
            min-width: 200px;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            backdrop-filter: blur(10px);
        }
        
        #p1-box { left: 30px; border-left: 6px solid #444; }
        #p1-box.active {
            border-left: 6px solid var(--neon-blue);
            background: linear-gradient(90deg, rgba(0, 243, 255, 0.15), rgba(0,0,0,0));
            box-shadow: 0 0 30px rgba(0, 243, 255, 0.1);
            transform: translateX(10px);
        }

        #p2-box { right: 30px; text-align: right; border-right: 6px solid #444; }
        #p2-box.active {
            border-right: 6px solid var(--neon-pink);
            background: linear-gradient(-90deg, rgba(188, 19, 254, 0.15), rgba(0,0,0,0));
            box-shadow: 0 0 30px rgba(188, 19, 254, 0.1);
            transform: translateX(-10px);
        }

        .p-label { font-family: 'Orbitron'; font-size: 13px; color: #888; letter-spacing: 2px; margin-bottom: 5px; text-transform: uppercase; font-weight: 700;}
        .p-score { font-family: 'Orbitron'; font-size: 36px; font-weight: 900; color: white; text-shadow: 0 2px 10px rgba(0,0,0,0.5); }
        
        #p1-box.active .p-score { color: var(--neon-blue); text-shadow: 0 0 20px rgba(0, 243, 255, 0.4); }
        #p2-box.active .p-score { color: var(--neon-pink); text-shadow: 0 0 20px rgba(188, 19, 254, 0.4); }

        #turn-popup {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%) scale(0.9);
            background: rgba(0,0,0,0.9);
            border: 1px solid rgba(255,255,255,0.2);
            padding: 30px 60px;
            font-family: 'Orbitron';
            font-size: 48px;
            font-weight: 900;
            text-transform: uppercase;
            pointer-events: none;
            opacity: 0;
            transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            z-index: 50;
            text-align: center;
            box-shadow: 0 0 60px rgba(0,0,0,0.8);
            border-radius: 12px;
            color: white;
        }
        #turn-popup.show { opacity: 1; transform: translate(-50%, -50%) scale(1); }

        /* --- CONTROL PANEL STYLES --- */
        .panel-header h2 { 
            margin: 0; 
            font-family: 'Orbitron'; 
            font-size: 28px; 
            color: #fff; 
            text-align: center;
            border-bottom: 2px solid #222;
            padding-bottom: 20px;
            letter-spacing: 4px;
            text-shadow: 0 0 15px rgba(255,255,255,0.1);
        }

        .control-group {
            background: #15161a;
            border: 1px solid #2a2a2a;
            padding: 20px;
            border-radius: 8px;
            margin-top: 20px;
        }
        
        .group-label {
            font-size: 11px; color: #666; letter-spacing: 1px; margin-bottom: 12px; 
            text-transform: uppercase; display: flex; justify-content: space-between; font-weight: 700;
        }

        .slots-grid { display: grid; grid-template-columns: repeat(7, 1fr); gap: 6px; }
        .slot-btn {
            background: linear-gradient(145deg, #1a1a1a, #111); 
            border: 1px solid #333; color: #555;
            aspect-ratio: 1; display: flex; align-items: center; justify-content: center;
            cursor: pointer; font-family: 'Orbitron'; font-weight: bold; font-size: 16px;
            transition: all 0.2s;
            border-radius: 6px;
            box-shadow: inset 0 2px 5px rgba(0,0,0,0.5);
        }
        .slot-btn:hover { border-color: var(--neon-blue); color: #fff; transform: translateY(-2px); box-shadow: 0 5px 15px rgba(0,0,0,0.3); }
        .slot-btn.active { 
            background: white; color: black; border-color: white; 
            box-shadow: 0 0 20px rgba(255,255,255,0.4); 
            transform: scale(1.1);
        }

        .btn-row { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; }
        .action-btn {
            padding: 18px; border: none; font-family: 'Orbitron'; font-weight: 900; 
            font-size: 15px; cursor: pointer; opacity: 0.4; pointer-events: none;
            text-transform: uppercase; color: #000;
            border-radius: 6px;
            letter-spacing: 1px;
            transition: all 0.2s;
        }
        .action-btn.ready { opacity: 1; pointer-events: all; }
        
        .btn-green { background: var(--neon-green); box-shadow: 0 5px 0 #005500; }
        .btn-green:active { box-shadow: 0 0 0; transform: translateY(5px); }
        .btn-green:hover { filter: brightness(1.1); box-shadow: 0 5px 0 #005500, 0 0 20px rgba(57, 255, 20, 0.4); }
        
        .btn-red { background: var(--neon-red); color: white; box-shadow: 0 5px 0 #550000; }
        .btn-red:active { box-shadow: 0 0 0; transform: translateY(5px); }
        .btn-red:hover { filter: brightness(1.1); box-shadow: 0 5px 0 #550000, 0 0 20px rgba(255, 0, 60, 0.4); }

        .log-box {
            flex-grow: 1;
            background: #050505;
            border: 1px solid #222;
            padding: 15px;
            margin-top: 20px;
            overflow-y: auto;
            font-family: 'Roboto Mono', monospace;
            font-size: 11px;
            color: #888;
            border-radius: 6px;
            box-shadow: inset 0 0 10px rgba(0,0,0,0.8);
        }
        .log-entry { 
            padding: 8px 0; 
            border-bottom: 1px solid #1a1a1a; 
            display: flex; justify-content: space-between;
            animation: fadeIn 0.3s ease-out;
        }
        @keyframes fadeIn { from { opacity: 0; transform: translateX(-10px); } to { opacity: 1; transform: translateX(0); } }

        .reset-btn {
            background: transparent; border: 1px solid #333; color: #666; 
            padding: 15px; cursor: pointer; font-family: 'Orbitron'; 
            font-size: 12px; transition: 0.2s; margin-top: 20px;
            width: 100%; border-radius: 6px; letter-spacing: 2px;
            text-transform: uppercase;
        }
        .reset-btn:hover { border-color: var(--neon-red); color: var(--neon-red); }

        /* --- START MODAL --- */
        #start-screen {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.92);
            z-index: 100;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            transition: opacity 0.5s;
            backdrop-filter: blur(5px);
        }
        #start-screen.hidden { opacity: 0; pointer-events: none; }

        .modal-box {
            background: #111;
            border: 1px solid #333;
            padding: 50px;
            border-radius: 12px;
            text-align: center;
            box-shadow: 0 0 80px rgba(0, 243, 255, 0.1);
            width: 340px;
            position: relative;
            overflow: hidden;
        }
        /* Neon Border Animation */
        .modal-box::before {
            content: ''; position: absolute; top: 0; left: 0; right: 0; height: 3px;
            background: linear-gradient(90deg, var(--neon-blue), var(--neon-pink));
        }

        .modal-title {
            font-family: 'Orbitron', sans-serif;
            font-size: 42px;
            margin-bottom: 40px;
            background: linear-gradient(to right, #fff, #aaa);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-transform: uppercase;
            letter-spacing: 6px;
            font-weight: 900;
        }
        .input-group { margin-bottom: 25px; text-align: left; }
        label { display: block; color: var(--neon-blue); font-size: 11px; margin-bottom: 8px; text-transform: uppercase; letter-spacing: 2px; font-weight: bold;}
        input[type="text"] {
            width: 100%;
            background: #0a0a0a;
            border: 1px solid #333;
            color: white;
            padding: 14px;
            font-family: 'Orbitron', sans-serif;
            font-size: 18px;
            outline: none;
            box-sizing: border-box;
            border-radius: 4px;
            transition: 0.3s;
        }
        input[type="text"]:focus { border-color: var(--neon-blue); box-shadow: 0 0 15px rgba(0,243,255,0.1); }
        .start-btn {
            background: linear-gradient(45deg, var(--neon-blue), #00aaff);
            border: none;
            color: black;
            padding: 18px 0;
            width: 100%;
            font-family: 'Orbitron', sans-serif;
            font-size: 18px;
            font-weight: 900;
            cursor: pointer;
            margin-top: 15px;
            transition: 0.2s;
            border-radius: 4px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        .start-btn:hover { filter: brightness(1.2); box-shadow: 0 0 30px rgba(0, 243, 255, 0.4); transform: scale(1.02); }

    </style>
</head>
<body>

<!-- START SCREEN -->
<div id="start-screen">
    <div class="modal-box">
        <div class="modal-title">THE WALL</div>
        <div class="input-group">
            <label>Player 1 (Blue)</label>
            <input type="text" id="p1Input" value="Blue Team" maxlength="12">
        </div>
        <div class="input-group">
            <label>Player 2 (Pink)</label>
            <input type="text" id="p2Input" value="Pink Team" maxlength="12">
        </div>
        <button class="start-btn" onclick="startGame()">ENTER ARENA</button>
    </div>
</div>

<!-- CONTROLS (LEFT SIDE) -->
<div id="control-panel">
    <div class="panel-header">
        <h2>CONTROLS</h2>
    </div>

    <!-- Zone Selector -->
    <div class="control-group">
        <div class="group-label">
            <span>Drop Zones</span>
            <span id="ballCount" style="color:var(--neon-blue)">0/3</span>
        </div>
        <div class="slots-grid" id="slotsContainer"></div>
    </div>

    <!-- Actions -->
    <div class="control-group">
        <div class="group-label">Reveal Outcome</div>
        <div class="btn-row">
            <button class="action-btn btn-green" id="btnGreen" onclick="triggerDrop('green')">CORRECT</button>
            <button class="action-btn btn-red" id="btnRed" onclick="triggerDrop('red')">WRONG</button>
        </div>
    </div>

    <!-- Log -->
    <div class="group-label" style="margin-top: 30px;">Event Log</div>
    <div class="log-box" id="gameLog">
        <div style="text-align:center; padding-top:20px; color:#444">Waiting for drop sequence...</div>
    </div>

    <button class="reset-btn" onclick="resetGame()">System Reset</button>
</div>

<!-- GAME STAGE (RIGHT SIDE) -->
<div id="game-stage">
    <canvas id="wallCanvas"></canvas>
    
    <!-- UI OVERLAYS -->
    <div id="p1-box" class="score-box active">
        <div class="p-label" id="name-0">PLAYER 1</div>
        <div class="p-score" id="score-0">$0</div>
    </div>

    <div id="p2-box" class="score-box">
        <div class="p-label" id="name-1">PLAYER 2</div>
        <div class="p-score" id="score-1">$0</div>
    </div>

    <div id="turn-popup">PLAYER 1 START</div>
</div>

<script>
    const canvas = document.getElementById('wallCanvas');
    const ctx = canvas.getContext('2d');
    const stage = document.getElementById('game-stage');

    // --- CONFIG & CONSTANTS ---
    const V_WIDTH = 1000;
    const V_HEIGHT = 1400; 
    let scale = 1;

    // Physics Tuning
    const GRAVITY = 0.45;
    const FRICTION = 0.99; // Less air resistance
    const RESTITUTION = 0.55; // Bounciness
    const DROP_ZONES = 7;
    const BIN_VALUES = [1, 1000, 100, 2000, 10, 5000, 100, 10000, 1, 25000, 10, 50000, 100, 100000, 1];

    // Game State
    let players = [{ name: "P1", score: 0, displayScore: 0 }, { name: "P2", score: 0, displayScore: 0 }];
    let currentPlayer = 0; 
    let ballsRemaining = 3;
    let isProcessing = false; 

    // Objects
    let balls = [];
    let pins = [];
    let bins = [];
    let zones = [];
    let particles = [];
    let floats = [];

    // Screen Shake
    let shakeIntensity = 0;

    // --- MATH HELPERS ---
    class Vector {
        constructor(x, y) { this.x = x; this.y = y; }
        add(v) { return new Vector(this.x + v.x, this.y + v.y); }
        sub(v) { return new Vector(this.x - v.x, this.y - v.y); }
        mult(n) { return new Vector(this.x * n, this.y * n); }
        dot(v) { return this.x * v.x + this.y * v.y; }
    }

    // --- ENTITIES ---
    class Ball {
        constructor(x, y, zoneId) {
            this.pos = new Vector(x, y);
            this.vel = new Vector(0, 0);
            this.radius = 14;
            this.active = true;
            this.hovering = true;
            this.zoneId = zoneId;
            this.color = 'white';
            this.trail = []; // Trail history
        }

        update() {
            if (!this.active || this.hovering) return;
            
            // Trail logic
            if (Math.random() > 0.1) {
                this.trail.push({x: this.pos.x, y: this.pos.y});
                if (this.trail.length > 10) this.trail.shift();
            }

            // Physics
            this.vel.y += GRAVITY;
            this.vel = this.vel.mult(FRICTION);
            this.pos = this.pos.add(this.vel);

            // Walls
            if (this.pos.x < this.radius) { this.pos.x = this.radius; this.vel.x *= -0.6; }
            if (this.pos.x > V_WIDTH - this.radius) { this.pos.x = V_WIDTH - this.radius; this.vel.x *= -0.6; }

            // Pins Collision
            for(let pin of pins) {
                let dx = this.pos.x - pin.x;
                let dy = this.pos.y - pin.y;
                let distSq = dx*dx + dy*dy;
                let minDist = this.radius + pin.r;
                
                if (distSq < minDist * minDist) {
                    let dist = Math.sqrt(distSq);
                    let normal = new Vector(dx/dist, dy/dist);
                    let chaos = new Vector((Math.random()-0.5)*1.8, (Math.random()-0.5)*1.8);
                    
                    let dot = this.vel.dot(normal);
                    let reflect = this.vel.sub(normal.mult(2 * dot));
                    
                    this.vel = reflect.add(chaos).mult(RESTITUTION);
                    this.pos = this.pos.add(normal.mult(minDist - dist));
                    
                    // Pin React
                    pin.hit = 1.0; 
                }
            }

            // Bin Logic
            if (this.pos.y > V_HEIGHT - 120) {
                for(let bin of bins) {
                    if (this.pos.x > bin.x && this.pos.x < bin.x + bin.w) {
                        if (this.pos.y > bin.y + 40) this.finish(bin);
                    }
                }
            }
        }

        finish(bin) {
            this.active = false;
            this.pos.x = bin.x + bin.w/2;
            this.pos.y = bin.y + bin.h/2;
            handleScore(bin.value, this.color, this.pos.x, this.pos.y);
            shakeIntensity = 5; // Screen impact
        }

        draw(ctx) {
            // Draw Trail
            if (!this.hovering && this.active) {
                ctx.beginPath();
                for(let i=0; i<this.trail.length; i++) {
                    let t = this.trail[i];
                    ctx.lineTo(t.x, t.y);
                }
                ctx.strokeStyle = this.color === 'green' ? 'rgba(57, 255, 20, 0.4)' : (this.color === 'red' ? 'rgba(255, 0, 60, 0.4)' : 'rgba(255,255,255,0.2)');
                ctx.lineWidth = this.radius;
                ctx.lineCap = 'round';
                ctx.stroke();
            }

            // Draw Ball
            ctx.beginPath();
            ctx.arc(this.pos.x, this.pos.y, this.radius, 0, Math.PI*2);
            let fill = '#fff';
            let glow = 'rgba(255,255,255,0.5)';
            if (this.color === 'green') { fill = '#39ff14'; glow = '#39ff14'; }
            if (this.color === 'red') { fill = '#ff003c'; glow = '#ff003c'; }
            
            ctx.shadowBlur = 20; ctx.shadowColor = glow; ctx.fillStyle = fill; ctx.fill();
            ctx.shadowBlur = 0;
            
            ctx.fillStyle = 'rgba(255,255,255,0.8)';
            ctx.beginPath(); ctx.arc(this.pos.x - 5, this.pos.y - 5, 5, 0, Math.PI*2); ctx.fill();
        }
    }

    // --- GAMEPLAY SYSTEM ---

    function startGame() {
        const p1Name = document.getElementById('p1Input').value || "P1";
        const p2Name = document.getElementById('p2Input').value || "P2";
        
        players[0].name = p1Name;
        players[1].name = p2Name;
        
        document.getElementById('name-0').innerText = p1Name;
        document.getElementById('name-1').innerText = p2Name;
        document.getElementById('score-0').innerText = "$0";
        document.getElementById('score-1').innerText = "$0";
        document.getElementById('gameLog').innerHTML = '';
        
        document.getElementById('start-screen').classList.add('hidden');
        
        currentPlayer = 0;
        ballsRemaining = 3;
        updateUI();
        announceTurn();
    }

    function announceTurn() {
        const popup = document.getElementById('turn-popup');
        const name = players[currentPlayer].name;
        const color = currentPlayer === 0 ? 'var(--neon-blue)' : 'var(--neon-pink)';
        
        popup.innerText = `${name}'S TURN`;
        popup.style.color = color;
        popup.style.borderColor = color;
        popup.style.boxShadow = `0 0 50px ${color}`;
        
        popup.classList.add('show');
        
        document.getElementById('p1-box').classList.toggle('active', currentPlayer === 0);
        document.getElementById('p2-box').classList.toggle('active', currentPlayer === 1);

        setTimeout(() => popup.classList.remove('show'), 1800);
    }

    function switchTurn() {
        currentPlayer = currentPlayer === 0 ? 1 : 0;
        ballsRemaining = 3;
        balls = [];
        updateUI();
        announceTurn();
    }

    function toggleZone(id) {
        if (isProcessing) return; 
        if (balls.some(b => !b.hovering)) return;

        let existing = balls.findIndex(b => b.zoneId === id);
        if (existing !== -1) {
            balls.splice(existing, 1);
        } else {
            if (balls.length < ballsRemaining) {
                let z = zones[id];
                balls.push(new Ball(z.x + z.w/2, z.y + z.h/2, id));
            }
        }
        updateUI();
    }

    function triggerDrop(type) {
        if (balls.length === 0 || balls.some(b => !b.hovering)) return;

        isProcessing = true;
        ballsRemaining -= balls.length;

        balls.forEach((b, i) => {
            b.color = type;
            setTimeout(() => {
                b.hovering = false;
                b.vel.x = (Math.random()-0.5) * 6; // Jitter
                b.vel.y = 2;
            }, i * 250);
        });

        updateUI();
    }

    function handleScore(val, type, x, y) {
        let amt = (type === 'green') ? val : -val;
        players[currentPlayer].score += amt;
        
        // Log Update
        const log = document.getElementById('gameLog');
        const item = document.createElement('div');
        item.className = 'log-entry';
        let color = amt >= 0 ? '#39ff14' : '#ff003c';
        let symbol = amt >= 0 ? '+' : '-';
        item.innerHTML = `<span style="color:${color}; font-weight:bold;">${symbol}$${val.toLocaleString()}</span> <span style="color:#aaa">${players[currentPlayer].name}</span>`;
        log.prepend(item);

        // Floats
        floats.push({
            txt: symbol + "$" + shortNum(val),
            x: x, y: y - 60, life: 1.0, 
            color: color
        });
        spawnParticles(x, y, type);

        // Check Round End
        if (balls.every(b => !b.active)) {
            setTimeout(() => {
                balls = [];
                isProcessing = false;
                if (ballsRemaining <= 0) {
                    switchTurn();
                } else {
                    updateUI();
                }
            }, 1200);
        }
    }

    function resetGame() {
        location.reload(); 
    }

    // --- RENDERING & INIT ---

    function resize() {
        const cw = stage.clientWidth;
        const ch = stage.clientHeight;
        const scaleX = cw / V_WIDTH;
        const scaleY = ch / V_HEIGHT;
        scale = Math.min(scaleX, scaleY) * 0.95;
        canvas.width = V_WIDTH * scale;
        canvas.height = V_HEIGHT * scale;
    }

    function initBoard() {
        // Zones
        const zoneW = V_WIDTH / DROP_ZONES;
        for(let i=0; i<DROP_ZONES; i++) zones.push({ x: i * zoneW, y: 20, w: zoneW, h: 80, id: i });

        // Pins (Staggered)
        const rows = 16; const cols = 15;
        const startY = 150; const endY = V_HEIGHT - 150;
        const usableW = V_WIDTH - 80;
        const stepX = usableW / (cols - 1);
        const stepY = (endY - startY) / rows;

        for(let r=0; r<rows; r++) {
            let count = (r % 2 === 0) ? cols : cols - 1;
            let xOff = (r % 2 === 0) ? 40 : 40 + stepX/2;
            for(let c=0; c<count; c++) pins.push({ x: xOff + (c * stepX), y: startY + (r * stepY), r: 5, hit: 0 });
        }

        // Bins
        const binW = V_WIDTH / 15;
        for(let i=0; i<15; i++) bins.push({ x: i * binW, y: V_HEIGHT - 120, w: binW, h: 120, value: BIN_VALUES[i] });
    }

    function loop() {
        // Rolling Score Logic (Lerp)
        players.forEach((p, i) => {
            let diff = p.score - p.displayScore;
            if (Math.abs(diff) > 0.5) {
                p.displayScore += diff * 0.1;
            } else {
                p.displayScore = p.score;
            }
            const el = document.getElementById(`score-${i}`);
            let val = Math.floor(p.displayScore);
            el.innerText = (val < 0 ? "-" : "") + "$" + Math.abs(val).toLocaleString();
        });

        // Screen Shake Decay
        if (shakeIntensity > 0) shakeIntensity *= 0.9;
        
        ctx.clearRect(0,0,canvas.width, canvas.height);
        
        // Background Grid
        ctx.save();
        ctx.strokeStyle = 'rgba(0, 243, 255, 0.05)';
        ctx.lineWidth = 2;
        ctx.beginPath();
        for(let i=0; i<canvas.width; i+=50) { ctx.moveTo(i,0); ctx.lineTo(i,canvas.height); }
        for(let i=0; i<canvas.height; i+=50) { ctx.moveTo(0,i); ctx.lineTo(canvas.width,i); }
        ctx.stroke();
        ctx.restore();

        // Main Board Transform
        ctx.save();
        
        let offsetX = (canvas.width - V_WIDTH * scale) / 2;
        let offsetY = (canvas.height - V_HEIGHT * scale) / 2;
        
        // Apply Shake
        if (shakeIntensity > 0.1) {
            offsetX += (Math.random()-0.5) * shakeIntensity * scale;
            offsetY += (Math.random()-0.5) * shakeIntensity * scale;
        }

        ctx.translate(offsetX, offsetY);
        ctx.scale(scale, scale);

        // Bins
        bins.forEach(b => {
            let isGold = b.value >= 100000;
            let grad = ctx.createLinearGradient(0, b.y, 0, b.y + b.h);
            grad.addColorStop(0, isGold ? 'rgba(255, 215, 0, 0.3)' : 'rgba(30, 30, 30, 0.5)');
            grad.addColorStop(1, isGold ? 'rgba(184, 134, 11, 0.8)' : 'rgba(10, 10, 10, 0.9)');
            
            ctx.fillStyle = grad; 
            ctx.fillRect(b.x+1, b.y, b.w-2, b.h); // Gap for glass look
            
            // Glass Highlight
            ctx.fillStyle = 'rgba(255,255,255,0.05)';
            ctx.fillRect(b.x+1, b.y, b.w-2, b.h/2);

            ctx.strokeStyle = isGold ? '#b8860b' : '#333'; 
            ctx.lineWidth = 1; 
            ctx.strokeRect(b.x, b.y, b.w, b.h);
            
            ctx.fillStyle = isGold ? '#ffd700' : '#888';
            ctx.font = 'bold 18px Rajdhani'; 
            ctx.textAlign = 'center';
            ctx.shadowColor = 'black'; ctx.shadowBlur = 4;
            ctx.fillText(shortNum(b.value), b.x + b.w/2, b.y + 70);
            ctx.shadowBlur = 0;
        });

        // Pins
        pins.forEach(p => { 
            // Pulse logic
            if (p.hit > 0) p.hit -= 0.05;
            let r = p.r + (p.hit * 4); // Expand when hit
            
            ctx.beginPath(); 
            ctx.arc(p.x, p.y, r, 0, Math.PI*2); 
            ctx.fillStyle = `rgba(255,255,255,${0.5 + p.hit})`;
            if (p.hit > 0.1) {
                ctx.shadowBlur = 15; ctx.shadowColor = 'white';
            }
            ctx.fill(); 
            ctx.shadowBlur = 0;
        });

        // Zones
        zones.forEach(z => {
            ctx.strokeStyle = 'rgba(0, 243, 255, 0.15)'; 
            ctx.lineWidth = 1;
            ctx.strokeRect(z.x+5, z.y, z.w-10, z.h);
            
            ctx.fillStyle = 'rgba(0, 243, 255, 0.3)'; 
            ctx.font = 'bold 30px Orbitron';
            ctx.fillText(z.id + 1, z.x + z.w/2, z.y + 50);
        });

        balls.forEach(b => { b.update(); b.draw(ctx); });
        drawFX(ctx);

        ctx.restore();
        requestAnimationFrame(loop);
    }

    function drawFX(ctx) {
        // Particles
        for(let i=particles.length-1; i>=0; i--) {
            let p = particles[i];
            p.x += p.vx; p.y += p.vy; p.life -= 0.02;
            p.vy += 0.1; // Gravity on confetti
            
            ctx.globalAlpha = Math.max(0, p.life);
            ctx.fillStyle = p.color; 
            ctx.fillRect(p.x, p.y, 4, 4); // Square confetti
            ctx.globalAlpha = 1;
            if (p.life <= 0) particles.splice(i, 1);
        }
        // Floats
        for(let i=floats.length-1; i>=0; i--) {
            let f = floats[i];
            f.y -= 2; f.life -= 0.015;
            
            ctx.save();
            ctx.globalAlpha = Math.max(0, f.life);
            ctx.fillStyle = f.color; 
            ctx.font = '900 48px Orbitron';
            ctx.textAlign = 'center';
            ctx.shadowColor = f.color; ctx.shadowBlur = 20;
            ctx.strokeStyle = 'black'; ctx.lineWidth = 5;
            ctx.strokeText(f.txt, f.x, f.y); 
            ctx.fillText(f.txt, f.x, f.y);
            ctx.restore();
            
            if (f.life <= 0) floats.splice(i, 1);
        }
    }

    function spawnParticles(x, y, type) {
        let c = type === 'green' ? '#39ff14' : '#ff003c';
        for(let i=0; i<30; i++) {
            particles.push({
                x, y, 
                vx:(Math.random()-0.5)*12, 
                vy:(Math.random()-0.5)*12 - 5, 
                life:1.0, 
                color:c
            });
        }
    }

    function shortNum(n) {
        if(n >= 1000000) return (n/1000000)+"M";
        if(n >= 1000) return (n/1000)+"k";
        return n;
    }

    function generateControls() {
        const c = document.getElementById('slotsContainer');
        c.innerHTML = '';
        for(let i=0; i<DROP_ZONES; i++) {
            let b = document.createElement('div');
            b.className = 'slot-btn'; b.innerText = i+1; b.id = 'slot-'+i;
            b.onclick = () => toggleZone(i);
            c.appendChild(b);
        }
    }

    function updateUI() {
        for(let i=0; i<DROP_ZONES; i++) {
            let btn = document.getElementById('slot-'+i);
            if(balls.some(b => b.zoneId === i)) btn.classList.add('active');
            else btn.classList.remove('active');
        }
        document.getElementById('ballCount').innerText = balls.length + "/" + ballsRemaining;

        const locked = balls.length === 0 || balls.some(b => !b.hovering) || isProcessing;
        document.getElementById('btnGreen').className = 'action-btn btn-green ' + (locked?'':'ready');
        document.getElementById('btnRed').className = 'action-btn btn-red ' + (locked?'':'ready');
    }

    initBoard();
    generateControls();
    resize();
    window.addEventListener('resize', resize);
    loop();

</script>
</body>
</html>